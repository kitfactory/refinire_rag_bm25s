# BM25s-j メタデータフィルタリング機能リクエスト

## 概要

BM25s-jライブラリにメタデータベースのフィルタリング機能を追加していただきたく、リクエストいたします。この機能により、検索時に特定のメタデータ条件に一致する文書のみを対象とした効率的な検索が可能になります。

## 背景・動機

### 現在の課題
- BM25s検索結果を後からメタデータでフィルタリングする必要がある（非効率）
- 大量の文書から特定カテゴリのみを検索したい場合にパフォーマンスが劣化
- RAGシステムにおけるドメイン固有検索の実装が困難

### 想定ユースケース
1. **ドメイン別検索**: 技術文書、法律文書、医療文書などカテゴリ別の検索
2. **時系列フィルタリング**: 特定期間の文書のみを対象とした検索
3. **権限ベース検索**: ユーザー権限に応じた文書への検索制限
4. **多言語対応**: 言語別での検索結果フィルタリング
5. **文書属性検索**: 難易度、重要度、ソースなどの属性による絞り込み

## 提案する機能仕様

### 1. 基本フィルタリング機能

#### インデックス作成時のメタデータサポート
```python
# 文書とメタデータのペアでインデックス作成
corpus = ["文書1", "文書2", "文書3"]
metadata = [
    {"category": "技術", "language": "ja", "difficulty": "中級"},
    {"category": "法律", "language": "ja", "difficulty": "上級"},
    {"category": "技術", "language": "en", "difficulty": "初級"}
]

# メタデータ付きインデックス作成
bm25.index(corpus, metadata=metadata)
```

#### 検索時のフィルタリング
```python
# 基本的なフィルタリング
results = bm25.retrieve(
    query="機械学習",
    k=10,
    filter={"category": "技術", "language": "ja"}
)

# 複数値フィルタリング
results = bm25.retrieve(
    query="法律",
    k=10,
    filter={"category": ["法律", "行政"], "difficulty": ["初級", "中級"]}
)
```

### 2. 高度なフィルタリング操作

#### 比較演算子サポート
```python
# 数値範囲フィルタリング
results = bm25.retrieve(
    query="データサイエンス",
    filter={
        "publish_date": {"$gte": "2023-01-01", "$lt": "2024-01-01"},
        "importance_score": {"$gt": 0.7}
    }
)

# 存在チェック
results = bm25.retrieve(
    query="Python",
    filter={"author": {"$exists": True}}
)

# 正規表現フィルタリング
results = bm25.retrieve(
    query="API",
    filter={"tags": {"$regex": "REST.*API"}}
)
```

#### 論理演算子サポート
```python
# AND/OR条件
results = bm25.retrieve(
    query="機械学習",
    filter={
        "$or": [
            {"category": "技術", "difficulty": "初級"},
            {"category": "教育", "level": "入門"}
        ]
    }
)

# NOT条件
results = bm25.retrieve(
    query="プログラミング",
    filter={"category": {"$ne": "廃止予定"}}
)
```

### 3. パフォーマンス最適化

#### インデックス構造の拡張
- メタデータ用の補助インデックス作成
- フィルタリング条件の事前コンパイル
- キャッシュ機能によるフィルタリング結果の再利用

#### メモリ効率化
- フィルタリング対象外文書の早期除外
- ストリーミング処理による大量文書対応
- インデックスの部分読み込み

## 提案するAPI設計

### 1. インデックス作成API

```python
import bm25s

# 基本的な使用法
bm25 = bm25s.BM25()
corpus = ["文書1", "文書2", "文書3"]
metadata = [
    {"category": "tech", "date": "2024-01-01", "score": 0.9},
    {"category": "legal", "date": "2024-01-02", "score": 0.8},
    {"category": "tech", "date": "2024-01-03", "score": 0.95}
]

# メタデータ付きでインデックス作成
bm25.index(corpus, metadata=metadata)
```

### 2. 検索API

```python
# 基本フィルタリング
results = bm25.retrieve(
    query="検索クエリ",
    k=10,
    filter={"category": "tech"}
)

# 複合フィルタリング
results = bm25.retrieve(
    query="検索クエリ",
    k=10,
    filter={
        "category": "tech",
        "score": {"$gte": 0.8},
        "date": {"$gte": "2024-01-01"}
    }
)

# 戻り値: (scores, indices, filtered_metadata)
scores, indices, metadata = results
```

### 3. フィルタービルダーAPI（オプション）

```python
from bm25s.filters import FilterBuilder

# フィルタービルダーによる直感的な条件構築
filter_condition = (
    FilterBuilder()
    .where("category").equals("tech")
    .and_("score").greater_than(0.8)
    .and_("tags").contains("machine learning")
    .build()
)

results = bm25.retrieve(query="AI", filter=filter_condition)
```

## 実装時の考慮事項

### 1. 後方互換性
- 既存のAPIを変更せず、オプション引数として追加
- メタデータなしでの従来通りの動作を保証
- 段階的な機能追加による影響最小化

### 2. パフォーマンス
- フィルタリングなしの場合は従来と同等の性能を維持
- メタデータインデックスのメモリ使用量最適化
- 大規模データセットでのスケーラビリティ確保

### 3. 型安全性
- TypeHintによる型チェック対応
- メタデータスキーマの検証機能（オプション）
- 実行時エラーの適切なハンドリング

## 期待される効果

### 1. パフォーマンス向上
- **現在**: BM25s検索(O(n)) → メタデータフィルタリング(O(m))
- **改善後**: メタデータフィルタリング(O(log m)) → BM25s検索(O(k)) ※k << n

### 2. 使いやすさ向上
- ワンステップでの条件付き検索
- 複雑なフィルタリングロジックの簡素化
- RAGシステムでの実装コスト削減

### 3. 活用範囲拡大
- エンタープライズ向けドキュメント検索システム
- 多言語・多ドメイン対応RAGシステム
- リアルタイムフィルタリング要求への対応

## 実装優先度

### Phase 1: 基本機能（高優先度）
- [ ] 基本的なequalityフィルタリング
- [ ] 複数条件ANDフィルタリング
- [ ] インデックス作成時のメタデータサポート

### Phase 2: 拡張機能（中優先度）
- [ ] 比較演算子（$gt, $lt, $gte, $lte）
- [ ] 配列操作（$in, $nin）
- [ ] 存在チェック（$exists）

### Phase 3: 高度機能（低優先度）
- [ ] 正規表現フィルタリング
- [ ] 論理演算子（$or, $and, $not）
- [ ] フィルタービルダーAPI

## 参考実装例

類似機能を持つライブラリの実装例：

1. **Elasticsearch**: 詳細なクエリDSLによるフィルタリング
2. **MongoDB**: 豊富な演算子によるドキュメントフィルタリング
3. **Pinecone**: メタデータフィルタリング付きベクトル検索
4. **Weaviate**: where句によるオブジェクトフィルタリング

## 代替案・回避策

### 現在の実装可能な回避策
1. **後フィルタリング**: 検索後にPython側でフィルタリング（非効率）
2. **事前分割**: カテゴリ別に複数のBM25インデックスを維持（管理複雑）
3. **クエリ拡張**: メタデータをテキストに埋め込み（検索精度低下）

### なぜネイティブサポートが必要か
- パフォーマンスの大幅向上
- メモリ使用量の最適化
- 開発・保守コストの削減
- エラー処理の一元化

## 質問・要望

1. この機能要求についてのご意見をお聞かせください
2. 実装予定や優先度についてお教えください
3. 設計面で考慮すべき点があればご指摘ください
4. コントリビューションの可能性についてご相談できればと思います

## 連絡先

この機能リクエストについてご質問や詳細の確認が必要でしたら、お気軽にお声がけください。

---

**補足**: 本リクエストはrefinire-rag統合プロジェクトでの実際のニーズに基づいており、多くのRAGシステム開発者にとって有益な機能と考えております。